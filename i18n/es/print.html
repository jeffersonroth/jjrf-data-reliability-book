<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ingeniería y Confiabilidad de Datos</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="assets/mdbook-admonish.css">
        <link rel="stylesheet" href="assets/catppuccin.css">
        <link rel="stylesheet" href="assets/catppuccin-highlight.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="COVER.html">Cover</a></li><li class="chapter-item expanded affix "><a href="TITLE.html">Título</a></li><li class="chapter-item expanded affix "><a href="SUMMARY.html">Índice</a></li><li class="chapter-item expanded affix "><a href="DEDICATION.html">Dedicatória</a></li><li class="chapter-item expanded affix "><a href="FOREWORD.html">Introducción</a></li><li class="chapter-item expanded affix "><a href="PREFACE.html">Prefacio</a></li><li class="chapter-item expanded affix "><a href="AUTHOR.html">Autor</a></li><li class="chapter-item expanded affix "><a href="OBJECTIVES.html">Objetivos</a></li><li class="chapter-item expanded affix "><a href="STRUCTURE.html">Estructura y Contenido</a></li><li class="chapter-item expanded "><a href="CONCEPTS.html"><strong aria-hidden="true">1.</strong> Conceptos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/systems_intro.html"><strong aria-hidden="true">1.1.</strong> Introducción a Sistemas</a></li><li class="chapter-item expanded "><a href="concepts/systems_reliability.html"><strong aria-hidden="true">1.2.</strong> Confiabilidad de Sistemas</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/impediments.html"><strong aria-hidden="true">1.2.1.</strong> Impedimentos: Fallos, Errores y Defectos</a></li><li class="chapter-item expanded "><a href="concepts/attributes.html"><strong aria-hidden="true">1.2.2.</strong> Atributos</a></li><li class="chapter-item expanded "><a href="concepts/mechanisms.html"><strong aria-hidden="true">1.2.3.</strong> Mecanismos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/fault_prevention_avoidance.html"><strong aria-hidden="true">1.2.3.1.</strong> Prevención de Fallos: Evitación</a></li><li class="chapter-item expanded "><a href="concepts/fault_tolerance.html"><strong aria-hidden="true">1.2.3.2.</strong> Tolerancia de Fallos</a></li><li class="chapter-item expanded "><a href="concepts/fault_prevention_elimination.html"><strong aria-hidden="true">1.2.3.3.</strong> Prevención de Fallos: Eliminación</a></li><li class="chapter-item expanded "><a href="concepts/fault_prediction.html"><strong aria-hidden="true">1.2.3.4.</strong> Predicción de Fallos</a></li><li class="chapter-item expanded "><a href="concepts/reliability_tools.html"><strong aria-hidden="true">1.2.3.5.</strong> Herramientas</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="concepts/data_quality.html"><strong aria-hidden="true">1.3.</strong> Calidad de Datos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/data_quality_intro.html"><strong aria-hidden="true">1.3.1.</strong> Fundamentos de la Calidad de Datos</a></li><li class="chapter-item expanded "><a href="concepts/master_data.html"><strong aria-hidden="true">1.3.2.</strong> Datos Maestros</a></li><li class="chapter-item expanded "><a href="concepts/data_management_processes.html"><strong aria-hidden="true">1.3.3.</strong> Calidad de los Procesos de Datos</a></li><li class="chapter-item expanded "><a href="concepts/data_quality_models.html"><strong aria-hidden="true">1.3.4.</strong> Modelos de Calidad de Datos</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/data_relibility.html"><strong aria-hidden="true">1.4.</strong> Confiabilidad de Datos</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.5.</strong> Procesos</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.6.</strong> Operaciones</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Casos de Uso</div></li><li class="chapter-item expanded affix "><a href="EPILOGUE.html">Epílogo</a></li><li class="chapter-item expanded affix "><a href="DICTIONARY.html">Diccionário</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">Referencias</a></li><li class="chapter-item expanded affix "><a href="NEXT.html">Próximas Ediciones</a></li><li class="chapter-item expanded affix "><a href="BACK_COVER.html">Back Cover</a></li><li class="chapter-item expanded affix "><a href="backlog.html">Backlog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ingeniería y Confiabilidad de Datos</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="Índice"><a class="header" href="#Índice">Índice</a></h1>
<p><a href="./COVER.html">Cover</a>
<a href="./TITLE.html">Título</a>
<a href="./SUMMARY.html">Índice</a>
<a href="./DEDICATION.html">Dedicatória</a>
<a href="./FOREWORD.html">Introducción</a>
<a href="./PREFACE.html">Prefacio</a>
<a href="./AUTHOR.html">Autor</a>
<a href="./OBJECTIVES.html">Objetivos</a>
<a href="./STRUCTURE.html">Estructura y Contenido</a></p>
<ul>
<li><a href="./CONCEPTS.html">Conceptos</a>
<ul>
<li><a href="./concepts/systems_intro.html">Introducción a Sistemas</a></li>
<li><a href="./concepts/systems_reliability.html">Confiabilidad de Sistemas</a>
<ul>
<li><a href="./concepts/impediments.html">Impedimentos: Fallos, Errores y Defectos</a></li>
<li><a href="./concepts/attributes.html">Atributos</a></li>
<li><a href="./concepts/mechanisms.html">Mecanismos</a>
<ul>
<li><a href="./concepts/fault_prevention_avoidance.html">Prevención de Fallos: Evitación</a></li>
<li><a href="./concepts/fault_tolerance.html">Tolerancia de Fallos</a></li>
<li><a href="./concepts/fault_prevention_elimination.html">Prevención de Fallos: Eliminación</a></li>
<li><a href="./concepts/fault_prediction.html">Predicción de Fallos</a></li>
<li><a href="./concepts/reliability_tools.html">Herramientas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./concepts/data_quality.html">Calidad de Datos</a>
<ul>
<li><a href="./concepts/data_quality_intro.html">Fundamentos de la Calidad de Datos</a></li>
<li><a href="./concepts/master_data.html">Datos Maestros</a></li>
<li><a href="./concepts/data_management_processes.html">Calidad de los Procesos de Datos</a></li>
<li><a href="./concepts/data_quality_models.html">Modelos de Calidad de Datos</a></li>
</ul>
</li>
<li><a href="./concepts/data_relibility.html">Confiabilidad de Datos</a></li>
<li><a href="">Procesos</a></li>
<li><a href="">Operaciones</a></li>
</ul>
</li>
<li><a href="">Casos de Uso</a></li>
</ul>
<p><a href="./EPILOGUE.html">Epílogo</a>
<a href="./DICTIONARY.html">Diccionário</a>
<a href="./REFERENCES.html">Referencias</a>
<a href="./NEXT.html">Próximas Ediciones</a>
<a href="./BACK_COVER.html">Back Cover</a></p>
<p><a href="./backlog.html">Backlog</a></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="conceptos"><a class="header" href="#conceptos">Conceptos</a></h1>
<blockquote>
<p>La idéa de introducir todos estos conceptos, es que el profesional internalize marcos de trabajo centrados en la confiabilidad, más que solamente hacer uso de herramientas o replicar casos de uso sin las bases sólidas que conllevan.</p>
</blockquote>
<p>Esta porción del libro se dedica a introducir los términos y conceptos de ingeniería, sistemas, confiabilidad, calidad y datos, bien cómo metodologías y herramientas sobre la Ingeniería y Confiabilidad de Datos.</p>
<p>Primeramente se hará una <a href="./concepts/systems_intro.html">Introducción a Sistemas</a>, dónde ...</p>
<p>Luego, sobre el tema de <a href="./concepts/systems_reliability.html">Confiabilidad de Sistemas</a>, que comprende una introducción sobre que es la confiabilidad, y cómo entenderla en el ámbito de sistemas, abordando temas como los impedimentos que puede sufrir el funcionamento de un sistema, y principalmente los mecanismos para asegurar la confiabilidad de los mismos.</p>
<p>Teniendo claro que es la confiabilidad, luego se explorará los conceptos de datos y calidad de datos, para que entonces sea posíble hablar de la confiabilidad de datos. El capítulo de <a href="./concepts/data_quality_intro.html">Calidad de Datos</a> explorará los fundamentos de calidad de datos, como el ciclo de vida de los datos, y temas de gobierno y gestión de los datos, los datos maestros, dónde exploramos su arquitectura, modelos de madurez y estándares, bien como la calidad de los procesos de datos y los diferentes modelos de calidad de datos. El capítulo de <a href="./concepts/data_relibility.html">Confiabilidad de Datos</a> ...</p>
<p>En el capítulo de <a href="">Procesos</a>, se explorará temas de definición de procesos dentro de sistemas, flojos de datos e información, flujos de trabajo, la orquestación de procesos, los DAGs, los pipelines, y por fin conceptos de ETL y ELT.</p>
<p>Para cerrar los capítulos conceptuales, tenemos el capítulo de <a href="">Operaciones</a>, que explorará temas de SRE, DataOps, DevOps, Lean Manufacturing, Six Sigma, metodologías ágiles, CD/CI, ...</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="confiabilidad-de-sistemas"><a class="header" href="#confiabilidad-de-sistemas">Confiabilidad de Sistemas</a></h1>
<blockquote>
<p>La confiabilidad de un sistema es la propiedad del sistema que permite calificar, justificadamente, como fiable al servicio que proporciona.</p>
</blockquote>
<p>El objetivo de este capítulo es introducir los conceptos de confiabilidad y seguridad explorados por Alan Burns y Andy Wellings en su libro &quot;Sistemas de Tiempo Real y Lenguajes de Programación&quot;, conceptos desarrollados por diferentes industrias principalmente entre los años 60 y 90, y los conceptos de Site Reliability Engineering (SRE) desarrollados a partir de los 2000, además de complementarlo con conceptos de confiabilidad trabajados en otras ingenierías (mecánica, industrial, etc.), bien cómo contextualizarlo con conceptos trabajados actualmente en la industria de software y sistemas informáticos.</p>
<h2 id="impedimentos"><a class="header" href="#impedimentos"><a href="concepts/./impediments.html">Impedimentos</a></a></h2>
<blockquote>
<p>Los impedimentos impiden el perfecto funcionamento de un sistema, o son consecuencia de este. En ese subcapítulo se trabajará la detección de los diferentes tipos de impedimentos, los cuales, los <strong>Fallos</strong>, <strong>Errores</strong> y <strong>Defectos</strong>.</p>
</blockquote>
<h2 id="atributos"><a class="header" href="#atributos"><a href="concepts/./attributes.html">Atributos</a></a></h2>
<blockquote>
<p>El modo y las medidas mediante las cuales se puede <strong>estimar la calidad de un servicio confiable</strong>.</p>
</blockquote>
<h2 id="mecanismos"><a class="header" href="#mecanismos"><a href="concepts/./mechanisms.html">Mecanismos</a></a></h2>
<blockquote>
<p>Los mecanismos los cuales se trabaja la confiabilidad de sistemas, sea por interiorización y adopción de buenas prácticas, sea por la aplicación de metodologías, arquitecturas o herramientas específicas. Este subcapítulo busca formar un <strong>marco de trabajo</strong> el cual los ingeníeros puedan adoptar la confiabilidad de sistemas desde el mismo diseño.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impedimentos-1"><a class="header" href="#impedimentos-1">Impedimentos</a></h1>
<h2 id="fallos-errores-y-defectos"><a class="header" href="#fallos-errores-y-defectos">Fallos, Errores y Defectos</a></h2>
<blockquote>
<p>Los <strong>fallos</strong> son el resultado de problemas internos no esperados que el sistema manifiesta eventualmente en su comportamiento externo. Estos problemas se llaman <strong>errores</strong>, y sus causas mecánicas o algorítmicas se denominan <strong>defectos</strong>. Cuando el comportamiento de un sistema se desvía del especificado para él, se dice que es un fallo.</p>
</blockquote>
<p>Los sistemas están compuestos de <strong>componentes</strong>, cada uno de los cuales se puede considerar como un sistema en sí mismo. Así, un fallo en un sistema puede inducir un defecto en otro, el cual puede acabar en un error y en un fallo potencial de este sistema. Esto puede continuar y producir un efecto en cualquier sistema relacionado, y así sucesivamente.</p>
<p>Un componente defectuoso de un sistema es un componente que producirá un error bajo un conjunto concreto de circunstancias durante la vida del sistema. Visto en términos de transición de estados, <em>un sistema puede ser considerado como un número de estados externos e internos</em>. </p>
<p>Un estado externo no especificado en el comportamiento del sistema se considerará un fallo del sistema. El sistema en sí mismo consta de un número de componentes (cada uno con sus propios estados), contribuyendo todos ellos al comportamiento externo del sistema. La combinación de los estados de estos componentes se denomina estado interno del sistema. <em>Un estado interno no especificado se considera un error, y el componente que produjo la transición de estados ilegal se dice que es defectuoso</em>.</p>
<p>Definiré tres tipos de fallos:</p>
<ul>
<li><strong>Fallos transitorios</strong>: comienza en un instante de tiempo concreto, se mantiene en el sistema durante algún periodo de tiempo, y luego desaparece.</li>
<li><strong>Fallos permanentes</strong>: comienzan en un instante determinado y permanecen en el sistema hasta que son reparados.</li>
<li><strong>Fallos intermitentes</strong>: son fallos transitorios que ocurren de vez en cuando.</li>
</ul>
<h2 id="modos-de-fallos"><a class="header" href="#modos-de-fallos">Modos de Fallos</a></h2>
<blockquote>
<p>Un sistema puede fallar de muchas maneras. Un diseñador puede diseñar el sistema suponiendo un número finito de modos de fallo, sin embargo el sistema puede fallar de manera diferente a lo esperado. </p>
</blockquote>
<p>Podemos clasificar los modos de fallos de los servicios que proporciona un sistema, los cuales:</p>
<ul>
<li><strong>Fallos de valor</strong>: el valor asociado con el servicio es erróneo.</li>
<li><strong>Fallo de tiempo</strong>: el servicio se completa a destiempo.</li>
<li><strong>Fallo arbitrario</strong>: combinación de fallos de valor y tiempo.</li>
</ul>
<p>Los modos de fallo de valor se denominan <strong>domínio de valor</strong>, y son clasificados en <strong>error de límites</strong>, y <strong>valor erróneo</strong>, dónde el valor se encuentra fuera del rango estipulado.</p>
<p>Los fallos en el dominio del tiempo pueden hacer que el servicio sea entregado:</p>
<ul>
<li><strong>Demasiado pronto</strong> (adelantado): el servicio se entrega antes de lo requerido.</li>
<li><strong>Demasiado tarde</strong> (retrasado o error de prestaciones): el servicio se entrega después de lo requerido.</li>
<li><strong>Infinitamente tarde</strong> (fallo de omisión): el servicio nunca es entregado.</li>
<li><strong>No esperado</strong> (fallo de encargo o improvisación): el servicio es entregado sin ser esperado.</li>
</ul>
<p>En general, podemos suponer los modos que un sistema puede fallar:</p>
<ul>
<li><strong>Fallo descontrolado</strong>: un sistema que produce errores arbitrales, tanto en el dominio del valor como en el del tiempo (incluyendo errores de improvisación).</li>
<li><strong>Fallo de retraso</strong>: un sistema que produce servicios correctos en el dominio del valor, pero que sufre errores de retraso en el tiempo.</li>
<li><strong>Fallo de silencio</strong>: un sistema que produce servicios correctos tanto en el dominio del valor como en el del tiempo, hasta que falla. El único fallo posible es el de omisión, y cuando ocurre, todos los servicios siguientes también sufrirán fallos de omisión.</li>
<li><strong>Fallo de parada</strong>: un sistema que tiene todas las propiedades de un fallo silencioso, pero que permite que otros sistemas puedan detectar que ha entrado en el estado de fallo de silencio.</li>
<li><strong>Fallo controlado</strong>: un sistema que falla de una forma especificada y controlada.</li>
<li><strong>Sin fallos</strong>: un sistema que siempre produce los servicios correctos.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atributos-1"><a class="header" href="#atributos-1">Atributos</a></h1>
<h2 id="confiabilidad"><a class="header" href="#confiabilidad">Confiabilidad</a></h2>
<blockquote>
<p>Es la probabilidad <em>R(t)</em> de que el sistema <strong>siga funcionando al final del proceso</strong>. El tiempo <em>t</em> se mide en horas continuas de trabajo entre diagnósticos. La tasa constante de fallos λ se mide en <em>fallos/h</em>. La vida útil de un componente del sistema es la región constante (escala logarítmica) de la curva entre vida del componente (Component Age) y su tasa de fallos (Failure Rate). La región de la gráfica antes del equilibrio es el Burn In Phase, y la región en donde la tasa de fallos empieza a crecer es el End of Life Phase. Así tenemos <em>R(t)=exp(-λt)</em>.</p>
</blockquote>
<h2 id="disponibilidad"><a class="header" href="#disponibilidad">Disponibilidad</a></h2>
<blockquote>
<p>Es la medida de la <strong>frecuencia de los periodos de servicio incorrecto</strong>.</p>
</blockquote>
<h2 id="fiabilidad"><a class="header" href="#fiabilidad">Fiabilidad</a></h2>
<blockquote>
<p>Continuidad de entrega del servicio. </p>
</blockquote>
<p>Es una medida (probabilidad) del <strong>éxito con el que el sistema se ajusta a la especificación definitiva de su comportamiento</strong>.</p>
<h2 id="seguridad"><a class="header" href="#seguridad">Seguridad</a></h2>
<blockquote>
<p>Es la ausencia de condiciones que pueden causar daños y propagación de <strong>daños catastróficos</strong> en producción.</p>
</blockquote>
<p>Sin embargo, como esa definición puede clasificar cómo inseguros virtualmente cualquier proceso, consideraremos a menudo el término <strong>percance</strong>.</p>
<blockquote>
<p>Un percance es un <strong>evento no planeado</strong> o secuencia de eventos que pueden producir daños catastróficos.</p>
</blockquote>
<p>Por mayores que sean su similitud con la definición de <strong>fiabilidad</strong>, se debe considerar la diferencia en su énfasis. La fiabilidad es la medida de éxito con la cual el sistema se ajusta a la especificación de su comportamiento, normalmente en términos de <strong>probabilidad</strong>. La seguridad, sin embargo, es la <strong>improbabilidad de que se den las condiciones que conducen a un percance, independientemente si se realiza la función prevista</strong>.</p>
<h2 id="integridad"><a class="header" href="#integridad">Integridad</a></h2>
<blockquote>
<p>Es la ausencia de condiciones que pueden llevar a alteraciones inapropiadas de los datos en producción. Es la <strong>improbabilidad de que se den las condiciones que alteran en producción datos inapropiados, independientemente si se realiza la función prevista</strong>.</p>
</blockquote>
<h2 id="mantenimiento"><a class="header" href="#mantenimiento">Mantenimiento</a></h2>
<blockquote>
<p>Capacidad de superar reparaciones y evolucionar.</p>
</blockquote>
<h2 id="escalabilidad"><a class="header" href="#escalabilidad">Escalabilidad</a></h2>
<blockquote>
<p>Capacidad de adecuación al negocio.</p>
</blockquote>
<h2 id="deficiencias"><a class="header" href="#deficiencias">Deficiencias</a></h2>
<blockquote>
<p>Circunstancias que causan o son producto de la no <strong>confiabilidad</strong>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mecanismos-1"><a class="header" href="#mecanismos-1">Mecanismos</a></h1>
<h2 id="prevención-de-fallos--evitación"><a class="header" href="#prevención-de-fallos--evitación"><a href="concepts/./fault_prevention_avoidance.html">Prevención de Fallos : Evitación</a></a></h2>
<h2 id="tolerancia-de-fallos"><a class="header" href="#tolerancia-de-fallos"><a href="concepts/./fault_tolerance.html">Tolerancia de Fallos</a></a></h2>
<h2 id="prevención-de-fallos-eliminación"><a class="header" href="#prevención-de-fallos-eliminación"><a href="concepts/./fault_prevention_elimination.html">Prevención de Fallos: Eliminación</a></a></h2>
<h2 id="predicción-de-fallos"><a class="header" href="#predicción-de-fallos"><a href="concepts/./fault_prediction.html">Predicción de Fallos</a></a></h2>
<h2 id="herramientas-de-confiabilidad"><a class="header" href="#herramientas-de-confiabilidad"><a href="concepts/./reliability_tools.html">Herramientas de Confiabilidad</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prevención-de-fallos--evitación-1"><a class="header" href="#prevención-de-fallos--evitación-1">Prevención de Fallos : Evitación</a></h1>
<p>Existen dos fases en la prevención de fallos: <strong>evitación y eliminación</strong>.</p>
<blockquote>
<p>Con la evitación se intenta limitar la introducción de datos y objetos potencialmente defectuosos durante la ejecución del proceso.</p>
</blockquote>
<p>Como:</p>
<ul>
<li>La utilización de fuentes de información validadas y limpias (cuando sea posible).</li>
<li>La introducción de procesos de limpieza y validación de los datos (data cruda).</li>
<li>La introducción de validación de disponibilidad de tablas y columnas, y la introducción de operadores de rama para su manejo.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tolerancia-de-fallos-1"><a class="header" href="#tolerancia-de-fallos-1">Tolerancia de Fallos</a></h1>
<blockquote>
<p>Debido a las limitaciones en las prevenciones de fallos, una vez que la data y los procesos cambian con frecuencia, es necesario recurrir a la tolerancia de fallos.</p>
</blockquote>
<p>Existen diferentes niveles de tolerancia a fallos:</p>
<ul>
<li><strong>Tolerancia total</strong>: no hay manejo de condiciones adversas o no deseadas, el proceso no se adapta a las validaciones y variables de entorno u otras informaciones externas para la ejecución de los tasks.</li>
<li><strong>Degradación controlada</strong> (o caída suave): notificaciones serán disparadas en la presencia de fallos, y siendo el suficiente importantes para interrumpir el flujo de tareas (thresholds, inexistencia o indisponibilidad de la data), los operadores de rama seleccionarán los tasks subsiguientes.</li>
<li><strong>Fallo seguro</strong>: los fallos detectados son suficientes para detectar que el proceso no debe ocurrir, un operador de cortocircuito cancela la ejecución de los subsiguientes tasks, los responsables son notificados, y caso no exista un proceso automático para lidiar con el problema, el equipo de data puede tomar acciones como volver a ejecutar los procesos que generan los inputs necesarios, o escalar el caso.</li>
</ul>
<p>El diseño de los procesos tolerantes a fallos supone:</p>
<ul>
<li>Los algoritmos de las tareas se han diseñado correctamente.</li>
<li>Se conocen todos los posibles modos de fallos de los componentes.</li>
<li>Se han tenido en cuenta todas las posibles interacciones entre el proceso y su entorno.</li>
</ul>
<h2 id="redundancia"><a class="header" href="#redundancia">Redundancia</a></h2>
<blockquote>
<p>Todas las técnicas utilizadas para conseguir tolerancia a fallos se basan en añadir elementos externos al sistema para que detecte y se recupere de fallos. Estos elementos son redundantes en el sentido de que no son necesarios para el normal funcionamiento del sistema, a esto llamamos <strong>redundancia protectora</strong>. El objetivo de la tolerancia es minimizar la redundancia, maximizando la fiabilidad, siempre bajo las restricciones de complejidad y tamaño del sistema. <strong>Se debe tener cuidado al diseñar los sistemas tolerantes a fallos, ya que los componentes incrementan la complejidad y mantenimiento de todo el sistema, lo que puede en sí, conducir a sistemas menos fiables</strong>.</p>
</blockquote>
<p>Clasificamos la redundancia en los sistemas en estáticas y dinámicas. La <strong>redundancia estática</strong>, o enmascaramiento, consiste en que los componentes redundantes son utilizados para ocultar los efectos de los fallos. La <strong>redundancia dinámica</strong> es la redundancia aportada dentro de un componente que hace que el mismo indique, implícita o explícitamente, que la salida es errónea; la recuperación debe ser proporcionada por otro componente. Esta técnica de tolerancia a fallos tiene cuatro fases:</p>
<ol>
<li><strong>Detección de errores</strong>: no se utilizará ningún esquema de tolerancia a fallos hasta que se haya detectado un error.</li>
<li><strong>Confinamiento y valoración de daños</strong>: cuando se detecte un error, debe estimarse la extensión del sistema que ha sido corrompida (diagnóstico de error) y su escopo.</li>
<li><strong>Recuperación del error</strong>: este es uno de los aspectos más importantes de la tolerancia a fallos. Las técnicas de recuperación de errores deberían dirigir al sistema corrupto a un estado a partir del cual pueda continuar con su normal funcionamiento (quizás con una degradación funcional).</li>
<li><strong>Tratamiento del fallo y continuación del servicio</strong>: un error es un síntoma de un fallo; aunque el daño pudiera haber sido reparado, el fallo continúa existiendo, y por lo tanto el error puede volver a darse a menos que se realice algún tipo de mantenimiento.</li>
</ol>
<h3 id="1-detección-de-errores"><a class="header" href="#1-detección-de-errores">1. Detección de errores</a></h3>
<blockquote>
<p>La efectividad de un sistema tolerante a fallos depende de la <strong>efectividad de detección de errores</strong>.</p>
</blockquote>
<p>La detección de errores se clasifican en:</p>
<ul>
<li><strong>Detecciones en el entorno</strong>. Los errores se detectan en el entorno en el cual se ejecutan el programa. Son manejados por las excepciones (exceptions).</li>
<li><strong>Detección en la aplicación</strong>. Los errores se detectan en la misma aplicación.
<ul>
<li><strong>Comprobaciones inversas</strong>. Aplicadas en componentes de relación isomórfica (uno a uno) entre la entrada y la salida. En este método, se toma la salida y se calcula la entrada, lo cual es comparado con el valor de entrada original. Para casos de números reales, es necesario adoptar técnicas de comparación inexactas.</li>
<li><strong>Comprobación de racionalidad</strong>. Se basan en el conocimiento del diseño y de la construcción del sistema. Comprueban que el estado de los datos o el valor de un objeto es razonable basándose en su supuesto uso.</li>
</ul>
</li>
</ul>
<h3 id="2-confinamiento-y-valoración-de-los-daños"><a class="header" href="#2-confinamiento-y-valoración-de-los-daños">2. Confinamiento y valoración de los daños</a></h3>
<blockquote>
<p>Siempre existirá una magnitud de tiempo, entre la ocurrencia de un defecto y la detección del error, siendo por lo tanto importante la valoración de cualquier daño que se haya podido producir en este intervalo de tiempo.</p>
</blockquote>
<p>Aunque el tipo de error detectado podrá dar ideas sobre el daño a la rutina de tratamiento del error, podrían haber sido diseminadas informaciones erróneas por el sistema y su entorno. Así, la valoración de los daños estará directamente relacionada con las precauciones tomadas por el diseñador de este sistema para el confinamiento del daño (<strong>construcción de cortafuegos</strong>). El confinamiento del daño se refiere a la estructuración del sistema de modo que se minimicen los daños causados por un componente defectuoso.</p>
<p>Existen dos técnicas principales para estructurar los sistemas de modo que se facilite el confinamiento de daños: <strong>descomposición modular</strong> y <strong>acciones atómicas</strong>. Por descomposición modular entiéndase que los sistemas deben ser descompuestos en componentes, cada uno de los cuales se representa por uno o más módulos. La interacción de los componentes se produce a través de interfaces bien definidas, y los detalles internos de los módulos están ocultos y no son accesibles directamente desde el exterior. Esto hace más difícil que un error en un componente pase indiscriminadamente a otro.</p>
<p>La descomposición modular proporciona al sistema una estructura estática, ya las acciones atómicas proporcionan al mismo una estructura dinámica. Se dice que una acción es atómica si no existen interacciones entre la actividad y el sistema durante el transcurso de la acción. Estas acciones se utilizan para mover el sistema de un estado consistente a otro, y para restringir el flujo de información entre los componentes.</p>
<h3 id="3-recuperación-de-errores"><a class="header" href="#3-recuperación-de-errores">3. Recuperación de errores</a></h3>
<blockquote>
<p>Una vez detectada la situación de error, y que sus posibles daños hayan sido valorados, se inician los procedimientos de recuperación de errores. Esta fase es probablemente la más importante dentro de las técnicas de tolerancia a fallos, la cual debe transformar un estado erróneo del sistema en otro desde el cual el sistema pueda continuar con su funcionamiento normal, quizás con una cierta degradación en el servicio.</p>
</blockquote>
<p>Aquí citaré dos estrategias para la recuperación de errores: recuperación <strong>hacia adelante</strong>, y <strong>hacia atrás</strong>. La recuperación de errores hacia adelante intenta continuar desde el estado erróneo realizando correcciones selectivas en el estado del sistema, que incluye proteger cualquier aspecto del entorno controlado que pudiera ser puesto en riesgo o dañado por el fallo.</p>
<p>La recuperación hacia atrás se basa en restaurar el sistema a un estado seguro previo a aquél en el que se produjo el error, para luego ejecutar una sección alternativa de la tarea. Ésta tendrá la misma funcionalidad que la sección que produjo el defecto, pero utilizando un algoritmo distinto. Se espera que esta alternativa no produzca el mismo defecto que la versión anterior, así que dependerá del conocimiento del diseñador sobre los posibles modos de fallo de este componente.</p>
<p>El diseñador debe tener claro los niveles de degradación de un servicio, teniendo en cuenta los servicios y procesos que dependen de éste. La recuperación de errores hace parte de los procesos de acción correctiva y acciones preventivas (CAPA - Corrective Action and Preventive Action Process), el cual se trabajará en dos momentos: en ese mismo capitulo de tolerancia a fallos cuando se trabajen las acciones correctivas, y en el próximo capitulo, prevención de fallos, cuando se aborde el tema de acciones preventivas.</p>
<h3 id="4-tratamiento-de-los-fallos-y-servicio-continuado"><a class="header" href="#4-tratamiento-de-los-fallos-y-servicio-continuado">4. Tratamiento de los fallos y servicio continuado</a></h3>
<blockquote>
<p>Un error es una manifestación de un defecto, y aunque la fase de recuperación del error puede haber llevado el sistema a un estado libre de error, el error se puede volver a producir. Por lo tanto, la fase final de la tolerancia de fallos es erradicar el fallo del sistema, de forma que se pueda continuar con el servicio normal.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prevención-de-fallos-eliminación-1"><a class="header" href="#prevención-de-fallos-eliminación-1">Prevención de Fallos: Eliminación</a></h1>
<p>La segunda fase de prevención de fallos es la eliminación de fallos. Consiste normalmente en procedimientos para encontrar y eliminar las causas de los errores. Aunque se pueden utilizar técnicas como los revisores de código (IDEs, linter) y el debugging en local, ni siempre se llevan a cabo las revisiones por pares y pruebas exhaustivas con las distintas combinaciones de estados de entrada y entorno. </p>
<p>Las pruebas en QA no pueden verificar que los valores de salida sean compatibles con el negocio y sus aplicaciones, así que se concentran normalmente en modos de fallo de tiempo (timeouts) y <strong>defectos</strong>. Desafortunadamente, la prueba del sistema no puede ser exhaustiva y eliminar todos los potenciales fallos, principalmente por:</p>
<ul>
<li>Las pruebas se utilizan para demostrar la presencia de fallos, no su ausencia.</li>
<li>La dificultad de realizar pruebas en producción. La manera de probar fallas en producción son del tipo <strong>combate real</strong>, o sea, la consecuencia de los errores pueden afectar directamente el negocio, haciendo que pueda tomar malas decisiones (ejemplo: un mal cálculo de un KPI, puede además de llevar a acciones erróneas, disminuir la confianza del negocio en los procesos de data). Existen alternativas de diseño de procesos para detección de fallos en producción, las cuales discutiré más adelante.</li>
<li>Los errores que han sido introducidos en la etapa de requisitos del sistema puede que no se manifiesten hasta que el sistema esté operativo. Ejemplo: Un DAG para el procesamiento y limpieza de la data de delivery de las campañas de marketing online que se diseñó para ejecutar antes del proceso de atribución de media, a las 4am, no llevó en consideración que la data no estará disponible hasta las 5am.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicción-de-fallos-1"><a class="header" href="#predicción-de-fallos-1">Predicción de Fallos</a></h1>
<p>La predicción acurada y rápida de los fallos posibilita a los que mantenemos los procesos asegurar mayor disponibilidad de los servicios. Desafortunadamente, la predicción de fallos es muchísimo menos sencilla que su detección.</p>
<p>Para poder predecir un fallo, éste debe ser identificado y clasificado. Los fallos también deben ser predecibles (o capaces de predicción), lo que significa que existen alteraciones de estados de los sistemas (y componentes) que llevan al fallo, o el fallo ocurre regularmente siguiendo algún patrón. Ambos casos pueden ser traducidos a problemas de predicción de series temporales, y la data de los sensores y logs puede ser trabajada para entrenar los modelos de predicción.</p>
<p>La data colectada muy difícilmente estará lista para ser utilizada por los modelos de predicción, así que uno o más tareas de preprocesamiento deben llevarse a cabo:</p>
<ul>
<li><strong>Sincronización de la data</strong>: las métricas colectadas por diversos agentes (sensores) deben alinearse en la dimensión de tiempo.</li>
<li><strong>Limpieza de la data</strong>: remoción de data innecesaria, y generación de data faltante (ej: interpolación).</li>
<li><strong>Normalización de la data</strong>: los valores de las métricas son normalizados para que las magnitudes sean comparables.</li>
<li><strong>Selección de features</strong>: las métricas relevantes son identificadas para su utilización en los modelos.</li>
</ul>
<p>Una vez preprocesada la data, la misma será utilizada en dos pipelines: pipeline de entrenamiento, y pipeline de inferencia. El pipeline de entrenamiento usa la data en bulk, para entrenar el modelo a ser disponibilizado al pipeline de inferencia. Los resultados de la inferencia indicará la existencia o no de tipos específicos de fallas, sobre la muestra de métricas monitoreadas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="herramientas-de-confiabilidad-1"><a class="header" href="#herramientas-de-confiabilidad-1">Herramientas de Confiabilidad</a></h1>
<h2 id="diagramas-de-blocos-de-confiabilidad"><a class="header" href="#diagramas-de-blocos-de-confiabilidad">Diagramas de blocos de confiabilidad</a></h2>
<blockquote>
<p>Los diagramas de blocos de confiabilidad (reliability block diagram, o RBD) es un método para diagramar e identificar como la confiabilidad de componentes (o subsistemas) <em>R(t)</em>, contribuyen para el éxito o fracaso de una redundancia. Es decir, es un método que puede ser utilizado para diseñar y optimizar componentes y seleccionar redundancias, visando bajar los failure rates.</p>
</blockquote>
<p>Un RBD es representado en una serie de blocos conectados (en série, en paralelo, o su combinación), indicando componentes redundantes, indicando el tipo de redundancia y su respectivo failure rate.</p>
<p>Al analizarse el diagrama, se indican componentes que fallaron y los que no fallaron. Si es posible encontrar una ruta o camino entre el inicio y el fin de proceso con componentes que no fallaron, se puede suponer que el proceso se puede completar.</p>
<p>Cada RBD debe incluir afirmaciones o sentencias listando todas las relaciones entre los componentes, es decir que condiciones llevarón a tomar un componente u otro en la ejecución del proceso.</p>
<p>Links:</p>
<ul>
<li><a href="https://moodle.univ-angers.fr/pluginfile.php/2071725/mod_resource/content/1/Reliability%20Engineering%20-%20ISMP%20-%20Chap%203%20-%20RBD.pdf">Université Angers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reliability_block_diagram">Wikipedia</a></li>
<li><a href="https://hpreliability.com/understanding-reliability-block-diagrams/">HPReliability</a></li>
<li><a href="https://www.sydneywater.com.au/web/groups/publicwebcontent/documents/document/zgrf/mdq2/~edisp/dd_046415.pdf">Sydney Water</a></li>
</ul>
<h2 id="failure-reporting-analysis-and-corrective-action-system-fracas"><a class="header" href="#failure-reporting-analysis-and-corrective-action-system-fracas">Failure Reporting, Analysis, and Corrective Action System (FRACAS)</a></h2>
<blockquote>
<p>FRACAS es un sistema o proceso definido para el reporte, clasificación y análisis de fallos, bien como la planeación de acciones correctivas de dichos fallos. Es parte del proceso guardar el historial de los análisis y acciones tomadas.</p>
</blockquote>
<p>Llevar a cabo dicho proceso supone automatizar el análisis de los logs de los procesos de data (logs), commits, pull requests y tickets.</p>
<p>La implementación de proceso es cíclica y se da por (FRACAS Kaizen Loop adaptado):</p>
<ul>
<li><strong>Failure Mode Analysis</strong>: analysis de los modos de fallos.</li>
<li><strong>Failure Codes Creation</strong>: creación de códigos de fallos, o la metodología para clasificarlos.</li>
<li><strong>Work Order History Analysis</strong>: análisis del historial de tickets enviados al equipo de data.</li>
<li><strong>Root Cause Analysis</strong>: análisis de las causas raíces.</li>
<li><strong>Strategy Adjustment</strong>: ajuste de estratégia.</li>
</ul>
<p>Links:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Failure_reporting,_analysis,_and_corrective_action_system">Wikipedia</a></li>
<li><a href="https://reliabilityweb.com/articles/entry/whats_the_fracas">Reliability Web</a></li>
<li><a href="https://ieeexplore.ieee.org/abstract/document/1285523">IEEE Best Practices</a></li>
</ul>
<h2 id="spare-parts-stocking-strategy"><a class="header" href="#spare-parts-stocking-strategy">Spare Parts Stocking Strategy</a></h2>
<blockquote>
<p>Con suerte siempre existirán disponibles fuentes de datos limpias, con complejas transformaciones y limpiezas, que ahorran tiempo y procesamiento, y que pueden ser usadas en multiples etapas de multiples procesos, sin embargo las mismas pueden temporalmente estar no disponibles o fallar. Una vez identificados tales fuentes, y constatado que son críticas a un sistema o proceso, es prudente tener tareas mínimas de limpieza y transformaciones que trabajen sobre los datos crudos o fuentes de la fuente, que quizas no resultará en datos finales con los mismos niveles de detalles, pero que serán lo suficiente buenos.</p>
</blockquote>
<p>Tales tareas no son diseñadas para hacer parte del flujo normal de los procesos, pero son &quot;piezas de recambio&quot;, disponibles para cuando los tiempos de mantenimiento son demasiado largos. El empleo de dichas tareas deben ser por el mínimo de tiempo posible, mientras el equipo tiene tiempo de resolver los fallos en la tarea original, o diseñar su reemplazo.</p>
<p>Links:</p>
<ul>
<li><a href="https://reliabilityweb.com/articles/entry/how_to_develop_a_spare_parts_stocking_strategy">ReliabilityWeb</a></li>
</ul>
<h2 id="availability-controls"><a class="header" href="#availability-controls">Availability Controls</a></h2>
<blockquote>
<p>Fallos de disponibilidad pueden ocurrir por un sin numero de razones (desde hardware hasta bugs), y algunos sistemas o procesos tienen suficiente relevancia para que controles de disponibilidad (availability controls) sean implementados, para asegurar que determinados servicios o data sigan disponibles cuando ocurra dichos fallos.</p>
</blockquote>
<p>Los controles de disponibilidad van desde el uso de backups periódicos de la data, snaps, timetravel, procesos redundantes, sistemas de respaldo en servidores locales o cloud, etc.</p>
<p>Links:</p>
<ul>
<li><a href="https://www.whitehatsec.com/glossary/content/availability-controls">WhiteHatSec</a></li>
<li><a href="https://www.lawinsider.com/clause/availability-control">Law Insider</a></li>
<li><a href="https://www.controlglobal.com/assets/14WPpdf/140324-ISA-ControlSystemsHighAvailability.pdf">Control Global</a></li>
</ul>
<h2 id="acciones-correctivas"><a class="header" href="#acciones-correctivas">Acciones Correctivas</a></h2>
<blockquote>
<p>Parte del CAPA (Corrective Action and Preventive Action Process), las acciones correctivas (CAP - Corrective Action Process) consisten en la detección de fallos, la determinación de sus causas raíces, las acciones de corrección, y la toma de medidas de prevención para que el mismo fallo vuelva a ocurrir por los mismos motivos. La definición completa se encuentra en la ISO 9001.</p>
</blockquote>
<p>Diversas herramientas y técnicas son utilizadas en diversas industrias para su aplicación, dentre ellas, PDCA (Plan, Do, Check, Act), DMAIC (Define. Measure, Analyse, Improve, Control), 8D, etc. De manera general cualquier herramienta, técnica o metodologia, es sumarizada en la ISO 9001, en siete &quot;pasos&quot;:</p>
<ol>
<li>Definir el problema. Consiste en definir que el problema sea real, identificar Quien, Qué, Cuando, Dónde y Por qué. En el mundo de la ingeniería de datos, ese paso debe ser, en lo posíble, automático, y el fallo debe ser detectado desde sensores.</li>
<li>Definir el escopo. Consiste en mensurar el problema a se resolver, conociendo su frecuencia, a que procesos o tareas, y stakeholders afecta. Para los procesos de data, muchos de los detalles de escopo ya deberían ser información conocida, desde el diseño de los procesos y tareas, ya la frecuencia puede ser levantada desde los procesos de observability y FRACAS.</li>
<li>Acciones de confinamiento o contención. Son medidas puntuales y adoptadas por el mínimo de tiempo posible, mientras se trabaja en la solución definitiva del fallo. De antemano, tales medidas ya deberían estar diseñadas, para cada tarea o sub-tarea. La selección de medidas debería estar automatizada, de no serlo, se deben implementar de inmediato.</li>
<li>Identificación de causas raíz. Diagnosis clara, precisa y completa del fallo. Su documentación hace parte del FRACAS.</li>
<li>Planeación de acciones correctivas. Consiste en la planeación de acciones de corrección basadas especificamente en la causa raíz.</li>
<li>Implementación de acciones correctivas. Consiste en la implementación final de las acciones correctivas en el proceso, que deben automaticamente estar disponibles cuando fallos similares se presenten.</li>
<li>Acompañamento de los resultados (Follow up). Documentación, comunicación, FRACAS completos.</li>
</ol>
<h2 id="antifragilidad"><a class="header" href="#antifragilidad">Antifragilidad</a></h2>
<blockquote>
<p>Inspirado en el libro <em>Antifragile: Things That Gain from Disorder</em> de Nissim Nicholas Taleb, la antifragilidad difere de los conceptos de resiliencia o robustez, dónde los sistemas buscan mantener su nivel de confiabilidad, sino que desde su diseño, los sistemas aumentar su confiabilidad con respecto a los inputs del sistema.</p>
</blockquote>
<p>La antifragilidad propone un cambio de diseño de los sistemas (en el escopo de este libro, procesos), los cuales comumente son diseñados para ser frágiles, en el sentido de que si el mismo opera fuera de sus requerimientos, lo mismo fallará. La antifragilidad propone lo contrário, diseñar sistemas que se vuelven mejores cuando expuestos a cargas fuera de los requerimientos. En ese sentido, los sistemas no son diseñados para responder solamente a lo esperado o anticipado, sino que interactúan con su entorno en tiempo real y se adaptan a ello.</p>
<ul>
<li>Self-healing</li>
<li>Real time sensoring, monitoring</li>
<li>Live FRACAS</li>
<li>System Health Management</li>
<li>Automatic Repair</li>
</ul>
<p>Links:</p>
<ul>
<li><a href="https://ntrs.nasa.gov/api/citations/20140010075/downloads/20140010075.pdf">NASA</a></li>
<li><a href="https://refuses.github.io/preprints/antifragile.pdf">Refuses</a></li>
</ul>
<h2 id="bulkhead-pattern"><a class="header" href="#bulkhead-pattern">Bulkhead Pattern</a></h2>
<blockquote>
<p>En el mundo náutico encontramos los mamparos, placas de madera que encontramos en los barcos, que buscan que el barco no naufrague cuando se tiene comprometida una porción del casco. Para los sistemas el Bulkhead Pattern adapta exactamente esa idea, de que un fallo en una porción del sistema no comprometa el sistema en su totalidad.</p>
</blockquote>
<p>Este design pattern es aplicado comumente en el desarrollo de software, consiste en no sobrecargar un servicio con más llamadas de las que puede soportar en un determinado tiempo, un ejemplo de eso es Hystrix, de Netflix.</p>
<p>Links:</p>
<ul>
<li><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">Netflix</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calidad-de-datos"><a class="header" href="#calidad-de-datos">Calidad de Datos</a></h1>
<h2 id="fundamentos-de-la-calidad-de-datos"><a class="header" href="#fundamentos-de-la-calidad-de-datos">Fundamentos de la Calidad de Datos</a></h2>
<h3 id="ciclo-de-vida-de-los-datos"><a class="header" href="#ciclo-de-vida-de-los-datos">Ciclo de vida de los datos</a></h3>
<h3 id="dama"><a class="header" href="#dama">DAMA</a></h3>
<h3 id="posmad"><a class="header" href="#posmad">POSMAD</a></h3>
<h3 id="cobit"><a class="header" href="#cobit">COBIT</a></h3>
<h3 id="gobierno-versus-gestión-de-los-datos"><a class="header" href="#gobierno-versus-gestión-de-los-datos">Gobierno versus Gestión de los datos</a></h3>
<h2 id="datos-maestros"><a class="header" href="#datos-maestros">Datos Maestros</a></h2>
<h3 id="arquitectura-mdm"><a class="header" href="#arquitectura-mdm">Arquitectura MDM</a></h3>
<h3 id="modelo-de-madurez"><a class="header" href="#modelo-de-madurez">Modelo de madurez</a></h3>
<h3 id="estándares"><a class="header" href="#estándares">Estándares</a></h3>
<h4 id="iso-8000"><a class="header" href="#iso-8000">ISO 8000</a></h4>
<h4 id="isoiec-22745"><a class="header" href="#isoiec-22745">ISO/IEC 22745</a></h4>
<h2 id="calidad-de-los-procesos-de-datos"><a class="header" href="#calidad-de-los-procesos-de-datos">Calidad de los procesos de datos</a></h2>
<h3 id="dama-dmbok"><a class="header" href="#dama-dmbok">DAMA DMBOK</a></h3>
<h3 id="modelo-de-aiken"><a class="header" href="#modelo-de-aiken">Modelo de Aiken</a></h3>
<h3 id="data-management-maturity-model-dmm"><a class="header" href="#data-management-maturity-model-dmm">Data Management Maturity Model (DMM)</a></h3>
<h3 id="modelo-ibm"><a class="header" href="#modelo-ibm">Modelo IBM</a></h3>
<h3 id="modelo-de-gartner"><a class="header" href="#modelo-de-gartner">Modelo de Gartner</a></h3>
<h3 id="tqdm"><a class="header" href="#tqdm">TQDM</a></h3>
<h3 id="dcam"><a class="header" href="#dcam">DCAM</a></h3>
<h3 id="modelo-mamd"><a class="header" href="#modelo-mamd">Modelo MAMD</a></h3>
<h2 id="modelos-de-calidad-de-datos"><a class="header" href="#modelos-de-calidad-de-datos">Modelos de calidad de datos</a></h2>
<h3 id="modelo-de-calidad-de-datos"><a class="header" href="#modelo-de-calidad-de-datos">Modelo de calidad de datos</a></h3>
<h3 id="medidas-de-calidad-de-datos"><a class="header" href="#medidas-de-calidad-de-datos">Medidas de calidad de datos</a></h3>
<h3 id="proceso-de-evaluación"><a class="header" href="#proceso-de-evaluación">Proceso de evaluación</a></h3>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="confiabilidad-de-datos"><a class="header" href="#confiabilidad-de-datos">Confiabilidad de Datos</a></h1>
<blockquote>
<p>Tomándose por base los fundamentos y metodologías desarrolladas por los <strong>Site Reliability Engineers</strong>, conocidos como los “firefighters” del mundo de la ingeniería de sistemas, los cuales construyen sistemas automatizados para optimizar la disponibilidad de las aplicaciones (reducir downtime), definiremos <strong>Data Reliability</strong> cómo la capacidad del equipo de data en entregar alta disponibilidad de la data durante todo el ciclo de vida de la misma. En resumen, garantizar los periodos de tiempo que la data no presenta inacurácia, no es faltante ni errónea.</p>
</blockquote>
<p>...</p>
<h2 id="consecuencias-de-la-confiabilidad"><a class="header" href="#consecuencias-de-la-confiabilidad">Consecuencias de la confiabilidad</a></h2>
<p>Consecuencias (en administrar el downtime de la data):</p>
<ul>
<li>Los equipos de data reducen de manera muy importante el tiempo perdido en “apagar incendios”, escalaciones y troubleshooting de la data. Utilizan ese tiempo para enfocarse en la construcción de una buena infraestructura, y en agregar valor a la data.</li>
<li>Los equipos de data son más rápidos en actualizar y modificar la infraestructura de la data, ya que tienen claro la confiabilidad del sistema.</li>
<li>Los equipos de data ganan el respeto y la confianza de los stakeholders, ya que entregan datos confiables de manera consistente.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="backlog"><a class="header" href="#backlog">Backlog</a></h1>
<h2 id="topics"><a class="header" href="#topics">Topics</a></h2>
<p><strong>Fault Tolerant Systems</strong>:</p>
<ul>
<li>General Reliability Development Hazard logs (FRACAS) [Redundancia]</li>
<li>High Availability [https://www.controlglobal.com/assets/14WPpdf/140324-ISA-ControlSystemsHighAvailability.pdf]</li>
<li>Technical documentation</li>
<li>Safety cases</li>
<li>Bulkhead</li>
<li>Change Control</li>
<li>Cold Standby</li>
<li>Defensive Design</li>
<li>Derating</li>
<li>Design Debt</li>
<li>Design Life</li>
<li>Design Thinking</li>
<li>Durability</li>
<li>Edge Case</li>
<li>Entropy</li>
<li>Error Tolerance</li>
<li>Fault Tolerance</li>
<li>Fail Well</li>
<li>Fail-Safe</li>
<li>Graceful Degradation</li>
<li>Mistake Proofing &amp; Poka Yoke Technique</li>
<li>No Fault Found</li>
<li>Resilience</li>
<li>Safety by Design</li>
<li>Self-Healing</li>
<li>Service Life</li>
<li>Systems Thinking</li>
<li>Testbed</li>
<li>Waer and Tear</li>
<li>Deconstructability</li>
<li>Refinement</li>
<li>Defense in Depth</li>
<li>FMEA Design and Process</li>
<li>Physics of Failure (PoF)</li>
<li>Built-in Self-test</li>
<li>Eliminating single point of failure (SPOF)</li>
</ul>
<p><strong>Analysis</strong>:</p>
<ul>
<li>Root Cause analysis</li>
<li>Fault tree analysis (FTA)</li>
<li>Failure mode and effects analysis (FMEA)</li>
<li>Failure mode, effects and criticality analysis (FMECA)</li>
<li>Reliability, Availability and Maintainability Study (RAMS)</li>
<li>Mission Readiness analysis</li>
<li>Functional System Failure analysis</li>
<li>Inherent Design Reliability analysis</li>
<li>Use/Load analysis and wear calculations</li>
<li>Fatigue and creep analysis</li>
<li>Component Stress analysis</li>
<li>Field failure monitoring</li>
<li>Field data analysis</li>
<li>Caution and warning analysis</li>
<li>Chaos Engineering</li>
<li>Reliability Risk Assessments</li>
<li>Hazard analysis</li>
<li>Manufactoring defect analysis</li>
<li>Residual Risk analysis (RCA)</li>
<li>Weibull</li>
<li>Accelerated Life Testing (ALT Analysis)</li>
<li>Material Strength analysis</li>
<li>Quality of Service</li>
<li>Quality Control</li>
<li>Defect Rate</li>
<li>Failure Rate</li>
<li>Mean Time Between Failures</li>
<li>Mean Time to Repair (MTTR)</li>
<li>Mean Corrective Maintenance Time (MCMT)</li>
<li>Mean Preventive Maintenance Time (MPMT)</li>
<li>Mean Maintenance Hours per Repair (MMH/Repair)</li>
<li>Maximum Corrective Maintenance Time (MaxCMT)</li>
</ul>
<p><strong>Data Quality</strong>:</p>
<ul>
<li>Data Quality Completeness</li>
<li>Data Quality Correctness</li>
<li>Data Quality Credibility</li>
<li>Data Quality Precision</li>
<li>Data Quality Relevance</li>
<li>Data Quality Timeliness</li>
<li>Data Quality Traceability</li>
<li>Data Integrity</li>
<li>Data Cleansing</li>
<li>Data Corruption</li>
<li>Data Degradation</li>
<li>Data Artifact</li>
<li>Data Rot</li>
<li>Information Quality Accurate</li>
<li>Information Quality Completeness</li>
<li>Information Quality Comprehensible</li>
<li>Information Quality Credibility</li>
<li>Information Quality Precision</li>
<li>Information Quality Relevance</li>
<li>Information Quality Timeliness</li>
<li>Information Quality Uniqueness</li>
<li>Conformance Quality</li>
<li>Credence Quality</li>
<li>Quality Assurance</li>
<li>Quality Control</li>
<li>Service Quality</li>
<li>Experience Quality</li>
<li>Code Smell</li>
<li>Referential Integrity</li>
<li>Reusability</li>
</ul>
<p><strong>Maintenance</strong>:</p>
<ul>
<li>Maintenance Requirement Allocation</li>
<li>Predictive and Preventive maintenance</li>
<li>Reliability Centered Maintenance (RCM)</li>
</ul>
<p><strong>Failures</strong>:</p>
<ul>
<li>Manufactoring-induced failures</li>
<li>Assembly-induced failures</li>
<li>Transport-induced failures</li>
<li>Storage-induced failures</li>
<li>Systmatic failures</li>
</ul>
<p><strong>Tests</strong>:</p>
<ul>
<li>System Diagnostics Design</li>
<li>Failure/Reliability testing</li>
</ul>
<p><strong>Human Factors</strong>:</p>
<ul>
<li>Human Factors</li>
<li>Human Interaction</li>
<li>Human Errors</li>
<li>Latent Human Error</li>
</ul>
<p><strong>DataOps</strong>:</p>
<p><strong>Business Process Management</strong>:</p>
<ul>
<li>BPM</li>
<li>BPI</li>
<li>BPE</li>
<li>BPA</li>
<li>BPR</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="assets/mermaid.min.js"></script>
        <script src="assets/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
